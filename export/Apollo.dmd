```set template default.html```
```set title Apollo cheat sheet```
```set autoapi ext```
```gmlapi fnames2```
```set intro
This is a "cheat sheet" for the "Apollo" extension (v3) by YellowAfterlife.\
The extension can be found on
[itch.io](https://yellowafterlife.itch.io/gamemaker-lua).
```
```exec
var helpURL = 'https://www.lua.org/manual/5.4/manual.html';
function seeChap(_id) {
	return render('(see [§' + _id + '](' + helpURL + '#' + _id + '))');
}
function seeDoc(_id) {
	return render('(see [' + _id + '](' + helpURL + '#' + _id + '))');
}
function luaFunc(_name) {
	return render('*C function:* [`' + _name + '`](' + helpURL + '#' + _name + ')');
}
function flatFunc(_name) {
	return render('*Flat function:* `' + _name + '`');
}

var svg = File.getContent("thumb-doc-opt.svg");
var b64 = Base64.encode(Bytes.ofString(svg)).toString();
return ["<style>.main { ",
"	background-repeat: no-repeat;"
"	background-position: top right;"
"	background-attachment: fixed;"
"	background-image: url(data:image/svg+xml;base64," + b64 + ");",
"}</style>"].join("\n");
```
```setmd butMultRet
but packs multiple returned values into an array ${seeChap("3.3.4")}
```
#[Concepts]() {
	#[Struct API and Flat API](struct-flat) {
		
	}
}
#[Lua states](+LuaState) {
	Lua states are now represented as structs!
	
	To create a Lua state, you do `state = new LuaState()` and it exists while it's being referenced.
	
	It has the following methods:
	
	#[toString()->](-) {
		Returns a short, unique string representation of the state.
		
		It'll usually look like this:
		```text
		LuaState(ptr:000000000474BEF0)
		```
	}
	#[Adding code](-adding-code) {
		Adding code:
		#[addCode(code)->](-) {
			Compiles and executes a snippet of Lua code ${seeDoc("luaL_dostring")}.
			
			If the code uses `return` statement, returns the first value.
			
			For example, doing
			```gml
			var state = new LuaState();
			state.addCode(@'
				print("Hello world!");
			');
			```
			would print "Hello world!" into GameMaker's Output panel.
		}
		#[addCodeMultRet(code)->array](-) {
			Like `addCode`, %[butMultRet].
		}
	}
	#[Global variables](-globals) {
		Working with globals:
		#[get(name)->](-) {
			Retrieves a global variable by a name.
			
			For tables and other reference types, this returns a [LuaRef](LuaRef),
			which allows further chaining to retrieve nested values:
			```gml
			var state = new LuaState();
			show_debug_message(state.get("math").get("pi")); // 3.14
			show_debug_message(state.get("string").get("reverse").call("123")); // 321
			```
			${luaFunc("lua_getglobal")}\
			${flatFunc("lua_global_get")}
		}
		#[set(name, value)](-) {
			Changes a value of a global variable.
			
			For example,
			```gml
			var state = new LuaState();
			state.set("game_version", "1.0.0");
			state.addCode(@'
				print(game_version) -- "1.0.0"
			');
			```
			
			If you need to change a value inside an object, you'll want to set() on a LuaRef instead:
			```gml
			var state = new LuaState();
			state.get("math").set("tau", pi * 2)
			state.addCode(@'
				print(math.tau) -- 6.2831853071796
			');
			```
			${flatFunc("lua_global_set")}
		}
		#[call(name, ...args)->](-) {
			${flatFunc("lua_global_call")}
		}
		#[callExt(name, argArray)->](-) {
			${flatFunc("lua_global_call_ext")}
		}
	}
}
#[GML↔Lua conversions](lua-gml) {
	#[Conversion rules] {
		Passing types between GML and Lua converts them as following:
		--{
		-	`undefined` ↔ `nil`
		-	`real` ↔ `number` (floating-point, 64-bit)
		-	`int64` ↔ `number` (integer, 64-bit)
		-	`int32` → `number` (integer, 64-bit)
		-	`string` ↔ `string`
		-	`LuaTable` ← `table`
		-	`LuaFunction` ← `function`
		-	`LuaUserdata` ← `userdata`
		-	`LuaRef` ← `lightuserdata`
		-	`array` → `GmlArray`
		-	`struct` → `GmlStruct`
		-	`method` → `GmlStruct`
		-	`instance` → `GmlStruct`
		}
		Passing a converted reference type back to where it came from
		(e.g. passing a `LuaTable` back into the Lua state) will represent
		it with the original value.
		
		Passing a Lua reference type from one state to another currently uses a
		special kind of `GmlStruct` as a proxy, so get/set/call operations will work,
		but other metafunctions won't.
	}
	#[Lua references in GML](+LuaRef) {
		Returning a Lua reference-based type (such as a table, function, or userdata) to GML
		will produce a `LuaRef` struct.
		
		It has the following methods:
		#[toString()->](-) {
			Returns a short, unique string representation of the value.
			
			It'll usually look like this:
			```text
			LuaRef(state:000000000474BEF0, uid:100000)
			```
		}
		#[typename()->](-) {
			Returns what exactly this is, anyway.
			
			Possible return values are: --{
				-	`"table"`
				-	`"function"`
				-	`"thread"`
				-	`"userdata"`
			}
		}
		---
		The following can be used if the value is a table or a userdata that
		has a metatable with appropriate metamethods ${seeChap("2.4")}.
		#[length()->](-) {
			Returns the length of the table, as per `#table` operator in Lua.
		}
		#[get(key)->](-) {
			Retrieves an item from a table, as with `table[key]` in Lua.
		}
		#[set(key, value)->](-) {
			Stores/changes an item in a table, as with `table[key] = value` in Lua.
		}
		---
		The following can be used if the value is a function or its metatable
		implements the `__call` metamethod ${seeChap("3.4.10")}.
		#[call(...args)->](-) {
			Invokes the value (if it's a function or has a `__call` in its metatable)
			and returns the result.
		}
		#[callMultRet(...args)->array](-) {
			Like `call`, but returns an array of resulting values ${seeChap("3.3.4")}.
		}
		#[callExt(argArray, ?argCount)->]() {
			Like `call`, but takes arguments as an array.
			
			If `argCount` is not provided, it'll be set to length of `argArray`.
		}
		#[callExtMultRet(argArray, ?argCount)->array]() {
			Combines the above two functions,
			taking arguments as an array and returning results as an array.
		}
	}
	#[GML references in Lua](GmlRef) {
		#[GmlArray](+) {
			Implements `__len`, `__index`, and `__newindex` ${seeChap("2.4")}.
			
			Pretends to be 1-indexed to save your end user some sanity.
		}
		#[GmlStruct](+) {
			Implements `__index`, `__newindex`, and `__call` ${seeChap("2.4")}.
			
			Methods also turn into `GmlStruct` (because they _are_ structs),
			much like numerous other "structy" new data types.
		}
	}
}
#[Raw API](lua_raw) {
	#[Stack manipulation](lua_stack) {
		```setmd stack
		a state's stack
		```
		#[lua_stack_size(state)->]() {
			Returns the number of elements on %[stack].
			
			${luaFunc("lua_gettop")}
		}
		#[lua_stack_clear(state)]() {
			Removes all elements from %[stack].
			
			${luaFunc("lua_settop")}
		}
		#[lua_stack_discard(state, count)]() {
			Removes N elements from %[stack].
			
			${luaFunc("lua_pop")}
		}
		#[lua_stack_resize(state, newSize)]() {
			Resizes %[stack]. This can discard existing values or push `nil`s to the stack.
			
			${luaFunc("lua_settop")}
		}
		#[lua_stack_ensure(state, count)->]() {
			Ensures that %[stack] has space for at least N extra elements.
			
			By default, Lua ensures that there's space for 20 extra items on the stack,
			so you'll want to call this before pushing a large/arbitrary number of elements
			${seeChap("4.1.1")}.
			
			[lua_stack_push]\[\_ext] calls this automatically, but other functions don't.
			
			Returns whether the request can be fulfilled.
			
			${luaFunc("lua_checkstack")}
		}
		---
		#[lua_stack_get(state, index)->]() {
			Returns an element of %[stack] at a position.
			
			Stack indexes are 1-based (first/bottom element is 1) but you can also use _negative_
			indexes to work with elements at the top of the stack ${seeChap("4.1")}.
		}
		---
		#[lua_stack_pop(state)->]() {
			Removes and returns a single value from %[stack].
		}
		#[lua_stack_pop_multret(state, count = -1)->]() {
			Removes and returns a number of values from %[stack] as an array.
			
			Use `-1` to pop all stack elements.
		}
		---
		#[lua_stack_push(state, ...values)]() {
			Pushes one or more values to %[stack].
		}
		#[lua_stack_push_ext(state, valArray, offset = 0, count = -1)]() {
			Pushes one or more values from an array to %[stack].
			
			Negative values for `count` will push the remainder of an array (length-offset).
		}
		#[lua_stack_push_global(state, name)]() {
			Pushes a global variable of a state to its stack.
			
			${luaFunc("lua_getglobal")}
		}
		#[lua_stack_push_new_table(state)]() {
			Pushes a new, empty table to %[stack].
			
			${luaFunc("lua_newtable")}
		}
		
	}
	#[Calls](lua_raw_calls) {
		#[lua_raw_call(state, numArgs)->]() {
			Performs a call with N arguments.
			The function/value to call precedes the arguments on the stack.
			
			For example, when you do `state.call("myfunc", 1, 2, 3)`, what Apollo does is
			```gml
			lua_stack_push_global(state);
			lua_stack_push(state, 1, 2, 3);
			return lua_raw_call(state, 3);
			```
			
			${luaFunc("lua_pcall")}
		}
		#[lua_raw_call_multret(state, numArgs)->]() {
			Like `lua_raw_call`, %[butMultRet].
		}
		#[lua_raw_call_ext(state, numArgs, numResults)->]() {
			Like `lua_raw_call`, but leaves returned value(s) on the stack.
			
			If `numResults` is -1, leaves it up to the function -
			you can use [lua_stack_size] to find out how many values were returned
			(and you should remove all of them from the stack afterwards).
			
			Otherwise makes sure that there are `numResults` values on the stack,
			either discarding the extra values or inserting `nil`s for the missing ones.
		}
	}
}
#[TODOs]() {
	--{
	-	Loading from file\
		Have to change working directory and then change it back,
		which works a little weird for some things.\
		And then people reported that you can't `require()` a path with non-Latin glyphs in it,
		but this somehow works in a few other Lua integrations.
	-	Lua coroutines\
		(did anyone actually use these?)
	-	Multi-returns from GML functions (`lua_return` in v2)\
		For now you can just return an array and unpack it on Lua side.
	-	GitHub Actions for cross-platform builds\
		However, GH Actions do not currently have an ARM Mac target.\
		Would I have to buy a second, newer Mac Mini just to make ARM extension builds?
	}
}